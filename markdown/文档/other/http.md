# http

## 1. 基本概念
### HTTP 是什么？描述一下

- HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。


### HTTP 常见的状态码，有哪些？
  
- 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
- 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
  - 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据
  - 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
  - 「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。.
- 3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
  - 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
  - 「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
  - 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
  - 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。
- 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
  - 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
  - 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
  - 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
  - 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
  - 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
  - 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
  - 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

### http 常见字段有哪些？

- Host
  - 客户端发送请求时，用来指定服务器的域名。
- Content-Length 字段
  - 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。
  - Content-Length: 1000
  - 如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。
- Connection 字段
  - Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
  - Connection: keep-alive
  - 一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。
- Content-Type 字段
  - Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
  - Content-Type: text/html; charset=utf-8
  - 上面的类型表明，发送的是网页，而且编码是UTF-8。
  - 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。
  - Accept: */*
  - 上面代码中，客户端声明自己可以接受任何格式的数据。
- Content-Encoding 字段
  - Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
  - Content-Encoding: gzip
  - 上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。
  - 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。
  - Accept-Encoding: gzip, deflate

## 2. GET 与 POST

### 说一下 GET 和 POST 的区别？

- Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。
- 比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
- 而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。
- 比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

### GET 和 POST 方法都是安全和幂等的吗？

- 先说明下安全和幂等的概念：
  - 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
  - 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
- 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
- POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。

## 3. HTTP 特性

### 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？

- HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。
- HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。
- HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
- 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。
- HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。
- 互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。


### 那它的缺点呢？

- HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。
- 无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
- 无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。
- 例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。
- 这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！
- 对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。
- Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
- 相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了，
- 明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。
- 但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。
- HTTP 比较严重的缺点就是不安全：
  - 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
  - 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
  - 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。
- HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。


### 那你说下 HTTP/1.1 的性能如何？

- HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。
- 1. 长连接
  - 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。
  - 为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
  - 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
- 2. 管道网络传输
  - HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。
  - 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
  - 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。
  - 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。
- 3. 队头阻塞
  - 「请求 - 应答」的模式加剧了 HTTP 的性能问题。
  - 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。
  - 总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。


## 4. HTTP 与 HTTPS

### HTTP 与 HTTPS 有哪些区别？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- HTTP 的端口号是 80，HTTPS 的端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。


### HTTPS 解决了 HTTP 的哪些问题？
- HTTP 由于是明文传输，所以安全上存在以下三个风险：
  - 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
  - 篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。
  - 冒充风险，比如冒充淘宝网站，用户钱容易没。
- HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。
- HTTP 与 HTTPS可以很好的解决了上述的风险：
  - 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
  - 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
  - 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。
- 可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。

### HTTPS 是如何解决上面的三个风险的？
- 混合加密的方式实现信息的机密性，解决了窃听的风险。
- 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到数字证书中，解决了冒充的风险。

### HTTPS 是如何建立连接的？其间交互了什么？
- SSL/TLS 协议基本流程：
  - 客户端向服务器索要并验证服务器的公钥。
  - 双方协商生产「会话秘钥」。
  - 双方采用「会话秘钥」进行加密通信。
- 前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。
- SSL/TLS 的「握手阶段」涉及四次通信，可见下图：




## 5. HTTP/1.1、HTTP/2、HTTP/3 演变

# 证明

### 什么是认证（Authentication）
- 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）
### 什么是授权（Authorization）
- 用户授予第三方应用访问该用户某些资源的权限
### 什么是凭证（Credentials）
- 是需要一种媒介（证书）来标记访问者的身份
- 在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

## 什么是 Cookie
- HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
- cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。
- cookie 重要的属性
  - 属性说明name=value键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。domain指定 cookie 所属域名，默认是当前域名path指定 cookie 在哪个路径（路由）下生效，默认是 '/'。如果设置为/abc，则只有/abc下的路由可以访问到该 cookie，如：/abc/read。maxAgecookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。-比 expires 好用。expires过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除secure该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。httpOnly如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全

## 什么是 Session
- session 是另一种记录服务器和客户端会话状态的机制
- session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

#



